<!DOCTYPE html><html><head><meta charset='utf-8'><title>キーワードを指定してタグジャンプ</title><link rel='stylesheet' href='bbs.css' /><script src='bbs.js'></script><body><ul class="side"><a href="./" class="toindex">←ansiトップへ</a><li><div class="list-title">
    <span class="no">3886</span>
    <a class="title" href="3886.html#3886">キーワードを指定してタグジャンプ</a></div>
    <ul><li><div class="list-title">
    <span class="no">3888</span>
    <a class="title" href="3886.html#3888">Re: キーワードを指定してタグジャンプ</a></div>
    <ul><li><div class="list-title">
    <span class="no">3890</span>
    <a class="title" href="3886.html#3890">Re2: キーワードを指定してタグジャンプ</a></div>
    <ul><li><div class="list-title">
    <span class="no">3891</span>
    <a class="title" href="3886.html#3891">Re3: キーワードを指定してタグジャンプ</a></div>
    <ul><li><div class="list-title">
    <span class="no">3892</span>
    <a class="title" href="3886.html#3892">Re4: キーワードを指定してタグジャンプ</a></div>
    <ul><li><div class="list-title">
    <span class="no">3894</span>
    <a class="title" href="3886.html#3894">Re5: キーワードを指定してタグジャンプ</a></div>
    <ul><li><div class="list-title">
    <span class="no">3901</span>
    <a class="title" href="3886.html#3901">Re6: キーワードを指定してタグジャンプ</a></div>
    <ul><li><div class="list-title">
    <span class="no">3905</span>
    <a class="title" href="3886.html#3905">Re7: キーワードを指定してタグジャンプ</a></div>
    </li><li><div class="list-title">
    <span class="no">3906</span>
    <a class="title" href="3886.html#3906">Re7: キーワードを指定してタグジャンプ</a></div>
    <ul><li><div class="list-title">
    <span class="no">3907</span>
    <a class="title" href="3886.html#3907">Re8: キーワードを指定してタグジャンプ</a></div>
    <ul><li><div class="list-title">
    <span class="no">3909</span>
    <a class="title" href="3886.html#3909">Re9: キーワードを指定してタグジャンプ</a></div>
    <ul><li><div class="list-title">
    <span class="no">3917</span>
    <a class="title" href="3886.html#3917">Re10: キーワードを指定してタグジャンプ</a></div>
    </li><li><div class="list-title">
    <span class="no">3918</span>
    <a class="title" href="3886.html#3918">Re10: キーワードを指定してタグジャンプ</a></div>
    </li></ul></li></ul></li></ul></li></ul></li><li><div class="list-title">
    <span class="no">3927</span>
    <a class="title" href="3886.html#3927">Re6: キーワードを指定してタグジャンプ</a></div>
    </li></ul></li></ul></li></ul></li></ul></li><li><div class="list-title">
    <span class="no">3938</span>
    <a class="title" href="3886.html#3938">Re2: キーワードを指定してタグジャンプ</a></div>
    <ul><li><div class="list-title">
    <span class="no">3973</span>
    <a class="title" href="3886.html#3973">Re3: キーワードを指定してタグジャンプ</a></div>
    </li></ul></li></ul></li></ul></li></ul><ul class="main"><li><section><h1 id=3886>
    <span class="no">[3886]</span>
    <a class="title" href="#3886">キーワードを指定してタグジャンプ</a>
    <span class="author">みく</span>
    <time datetime="2005-03-31T18:55:55">2005年03月31日 18:55</time></h1>
    <div class="body"><br>検索メニューの「キーワードを指定してタグジャンプ」から実行してください。<br>キーワードのところに文字を入力すると、一致するキーワードが表示されます。<br><br>ssrc_2005-02-04に対する差分です。<br>eGroups:Source/tagjump_key.lzh<br></div></section>
    <ul><li><section><h1 id=3888>
    <span class="no">[3888]</span>
    <a class="title" href="#3888">Re: キーワードを指定してタグジャンプ</a>
    <span class="author">げんた</span>
    <time datetime="2005-03-31T23:35:45">2005年03月31日 23:35</time></h1>
    <div class="body">きた～～．ということで早速試させて頂きました．<br><br>手入力の場合は大文字と小文字の区別無しの方がうれしいかも．<br>あと，先頭からの一致じゃなくて途中への一致もあるとキー入力を少なくできてうれしいなぁと．<br>ただ途中への一致も認めた場合，一文字や二文字で検索すると引っかかりすぎてしまう懸念はありますが，これは最大数を超えたら打ち切られるのでまあ大丈夫か．<br>いずれも場合によって使い分けたいので，検索オプションがあるとうれしいと思います．<br><br>TAGJUMP_EDITBOX_IS_COMBOというが残ってますが，コンボボックスで過去のパターンを残せるようにするつもりだったのでしょうか．検索の履歴が残っていた方が便利ではありますが．<br><br>AddParamでは数が多すぎる場合に処理を打ち切っていますが，SetDataで戻り値をチェックしていないのでファイル末尾まで常に読んでしまうのでは？<br><br>CDlgTagJumpList::AddParam()のMAXチェックはCSortedTagJumpList()のメソッド(IsOverflowとか)にする方が最大値を利用する側で考慮不要になるので良いと思います．MAX_TAGJUMPLISTはメモリ確保には使っていないので，constメンバ変数としておいてオブジェクト生成時に最大値を決定する方が良いかな？<br><br>最後に，早速新形式の@paramを使っているところがスバラシイです．<br></div></section>
    <ul><li><section><h1 id=3890>
    <span class="no">[3890]</span>
    <a class="title" href="#3890">Re2: キーワードを指定してタグジャンプ</a>
    <span class="author">みく</span>
    <time datetime="2005-04-04T20:53:00">2005年04月04日 20:53</time></h1>
    <div class="body">&gt;手入力の場合は大文字と小文字の区別無しの方がうれしいかも．<br><br>実装しました。<br><br>&gt;あと，先頭からの一致じゃなくて途中への一致もあるとキー入力を少なくできてうれしいなぁと．<br><br>実装しました。<br>（StrStrIがどのOSにもあるかが不明なのが心配）<br><br>&gt;TAGJUMP_EDITBOX_IS_COMBOというが残ってますが，コンボボックスで過去のパターンを残せるようにするつもりだったのでしょうか．検索の履歴が残っていた方が便利ではありますが．<br><br>コンボにしました。<br><br>&gt;CDlgTagJumpList::AddParam()のMAXチェックはCSortedTagJumpList()のメソッド(IsOverflowとか)にする方が最大値を利用する側で考慮不要になるので良いと思います．<br><br>修正しました。<br><br>＃結局tagsのサーチは力技なんですよね<br><br>時間がないもので、あんまり動作確認できてません。<br>みなさん使ってみてくださぃ<br><br><br>eGroups:Source/tagjump_key0404.lzh<br></div></section>
    <ul><li><section><h1 id=3891>
    <span class="no">[3891]</span>
    <a class="title" href="#3891">Re3: キーワードを指定してタグジャンプ</a>
    <span class="author">げんた</span>
    <time datetime="2005-04-04T22:42:06">2005年04月04日 22:42</time></h1>
    <div class="body">お忙しいところありがとうございます．<br><br>OverflowチェックでCSortedTagJumpList::m_bOverflowというフラグを使っていますが，これだとMAXを超えて1回溢れたところでフラグがONになりますよね．<br>フラグを設けなくても<br>bool IsOverflow( void ){ return m_nCount &gt;= MAX_TAGJUMPLIST; }<br>とすれば1回の溢れも回避できて問題ないように見えますが，なんか意図があるんでしょうか．<br><br>&gt;StrStrIがどのOSにもあるかが不明なのが心配<br>Windows 2000, Windows NT 4.0 with Internet Explorer 4.0, Windows 98, Windows 95 with Internet Explorer 4.0<br><br>IEの入っていないWindows 95で起動できないと困る人はまだいるのかなぁ．(すいさん？)<br>MSのサポートから外れたとはいえ結構特殊な環境下で使っている人もいるかもしれないので，他の実現手段があれば回避したいところではあります．<br></div></section>
    <ul><li><section><h1 id=3892>
    <span class="no">[3892]</span>
    <a class="title" href="#3892">Re4: キーワードを指定してタグジャンプ</a>
    <span class="author">みく</span>
    <time datetime="2005-04-04T23:04:26">2005年04月04日 23:04</time></h1>
    <div class="body"><br>&gt;OverflowチェックでCSortedTagJumpList::m_bOverflowというフラグを使っていますが，これだとMAXを超えて1回溢れたところでフラグがONになりますよね．<br>&gt;フラグを設けなくても<br>&gt;bool IsOverflow( void ){ return m_nCount &gt;= MAX_TAGJUMPLIST; }<br>&gt;とすれば1回の溢れも回避できて問題ないように見えますが，なんか意図があるんでしょうか．<br><br>昇順で並べて最初のn件を保持します。<br>複数のフォルダにtagsファイルがあるときのための対応です。<br>（もう少しうまい方法ないかなぁ）<br><br>StrStrIはやっぱ自作しないと駄目なようですね。<br>my_icmp.cppあたりに追加しましょう。<br></div></section>
    <ul><li><section><h1 id=3894>
    <span class="no">[3894]</span>
    <a class="title" href="#3894">Re5: キーワードを指定してタグジャンプ</a>
    <span class="author">みく</span>
    <time datetime="2005-04-05T18:44:10">2005年04月05日 18:44</time></h1>
    <div class="body"><br>早速バグ修正です。<br><br>CDlgTagJumpList.h:49行目<br>#define TAG_FORMAT          "%[^\t\r\n]\t%[^\t\r\n]\t%d;\"\t%s\t%s"<br><br>CDlgTagJumpList.cpp:668行目<br>if( (!m_bTagJumpICase) &amp;&amp; (!m_bTagJumpAnyWhere) ) break;<br><br><br>タグジャンプのキーワードに"operator +="みたいなのがあるので.<br></div></section>
    <ul><li><section><h1 id=3901>
    <span class="no">[3901]</span>
    <a class="title" href="#3901">Re6: キーワードを指定してタグジャンプ</a>
    <span class="author">みく</span>
    <time datetime="2005-04-07T20:13:39">2005年04月07日 20:13</time></h1>
    <div class="body"><br>char* my_strstri( const char* s1, const char* s2 )<br>{<br>&#9;size_t n = strlen( s2 );<br>&#9;for( const char* p1 = s1; *p1; p1++ ){<br>&#9;&#9;if( my_strnicmp( p1, s2, n ) == 0 ) return p1;<br>&#9;&#9;if( my_iskanji1( *p1 ) &amp;&amp; *(p+1) != 0 ) p1++;<br>&#9;}<br>&#9;return NULL;<br>}<br><br>char* my_strstr( const char* s1, const char* s2 )<br>{<br>&#9;size_t n = strlen( s2 );<br>&#9;for( const char* p1 = s1; *p1; p1++ ){<br>&#9;&#9;if( strncmp( p1, s2, n ) == 0 ) return p1;<br>&#9;&#9;if( my_iskanji1( *p1 ) &amp;&amp; *(p+1) != 0 ) p1++;<br>&#9;}<br>&#9;return NULL;<br>}<br><br>char* my_strchri( const char* s1, char c2 )<br>{<br>&#9;char C2 = my_toupper( c2 );<br>&#9;for( const char* p1 = s1; *p1; p1++ ){<br>&#9;&#9;if( my_toupper( *p1 ) == C2 ) return p1;<br>&#9;&#9;if( my_iskanji1( *p1 ) &amp;&amp; *(p+1) != 0 ) p1++;<br>&#9;}<br>&#9;return NULL;<br>}<br><br>char* my_strchr( const char* s1, char c2 )<br>{<br>&#9;for( const char* p1 = s1; *p1; p1++ ){<br>&#9;&#9;if( *p1 == c2 ) return p1;<br>&#9;&#9;if( my_iskanji1( *p1 ) &amp;&amp; *(p+1) != 0 ) p1++;<br>&#9;}<br>&#9;return NULL;<br>}<br></div></section>
    <ul><li><section><h1 id=3905>
    <span class="no">[3905]</span>
    <a class="title" href="#3905">Re7: キーワードを指定してタグジャンプ</a>
    <span class="author">げんた</span>
    <time datetime="2005-04-10T21:00:15">2005年04月10日 21:00</time></h1>
    <div class="body">Thanks...ですが今回の変更箇所以外でstrstr, strchr使われている部分も置き換えないとまずい？？<br></div></section>
    </li><li><section><h1 id=3906>
    <span class="no">[3906]</span>
    <a class="title" href="#3906">Re7: キーワードを指定してタグジャンプ</a>
    <span class="author">げんた</span>
    <time datetime="2005-04-10T21:08:17">2005年04月10日 21:08</time></h1>
    <div class="body">ヘッダファイル my_icmp.h<br><br>// 2005.04.07 MIK strstr系関数追加<br>#ifdef strstr<br>#  undef strstr<br>#endif<br>#define strstr(a,b)        my_strstr((a),(b))<br>#ifdef strstri<br>#  undef strstri<br>#endif<br>#define strstri(a,b)        my_strstri((a),(b))<br>#ifdef strchr<br>#  undef strchr<br>#endif<br>#define strchr(a,b)        my_strchr((a),(b))<br>#ifdef strchri<br>#  undef strchri<br>#endif<br>#define strchri(a,b)        my_strchri((a),(b))<br><br>// 2005.04.07 MIK strstr系関数追加<br>SAKURA_CORE_API int __cdecl char* my_strstri( const char* s1, const char* s2 );<br>SAKURA_CORE_API int __cdecl char* my_strstr( const char* s1, const char* s2 );<br>SAKURA_CORE_API int __cdecl char* my_strchri( const char* s1, char c2 );<br>SAKURA_CORE_API int __cdecl char* my_strchr( const char* s1, char c2 );<br><br>とここまで書いて気付いたこと．<br>1つ目の引数がchar*の場合とconst char*の場合で戻り値のconstの有無が切り替わるように両方定義しないとまずいような．<br></div></section>
    <ul><li><section><h1 id=3907>
    <span class="no">[3907]</span>
    <a class="title" href="#3907">Re8: キーワードを指定してタグジャンプ</a>
    <span class="author">げんた</span>
    <time datetime="2005-04-10T22:57:17">2005年04月10日 22:57</time></h1>
    <div class="body">&gt;とここまで書いて気付いたこと．<br>どころか全然デバッグしてないじゃん...(T_T)<br><br>const char*と__cdeclを同居させようとしてもコンパイルエラーになるんですが，どう書けばいいんでしょう．<br>そもそも__cdeclって本当に必要なの？<br></div></section>
    <ul><li><section><h1 id=3909>
    <span class="no">[3909]</span>
    <a class="title" href="#3909">Re9: キーワードを指定してタグジャンプ</a>
    <span class="author">みく</span>
    <time datetime="2005-04-11T18:39:00">2005年04月11日 18:39</time></h1>
    <div class="body"><br>直接掲示板にコーディングしてたんで、バグだらけでした。すいません。<br>__cdeclはstring.h互換にするために付けてるだけなんで、除いちゃってもかまいません。<br>strstrとstrchrは置き換えたら（￥とかで）効果ありそうなんですが、<br>サクラの場合、p[i]=='\\'なんてしてるのがほとんどなので、あんまり意味ないです。<br><br>SAKURA_CORE_API char* __cdecl my_strstri( const char* s1, const char* s2 );<br>SAKURA_CORE_API char* __cdecl my_strstr( const char* s1, const char* s2 );<br>SAKURA_CORE_API char* __cdecl my_strchri( const char* s1, int c2 );<br>SAKURA_CORE_API char* __cdecl my_strchr( const char* s1, int c2 );<br><br>char* my_strstri( const char* s1, const char* s2 ){<br>&#9;size_t n = strlen( s2 );<br>&#9;for( const unsigned char* p1 = (const unsigned char*)s1; *p1; p1++ ){<br>&#9;&#9;if( my_strnicmp( (const char*)p1, s2, n ) == 0 ) return (char*)p1;<br>&#9;&#9;if( my_iskanji1( *p1 ) &amp;&amp; *(p1+1) != 0 ) p1++;<br>&#9;}<br>&#9;return NULL;<br>}<br><br>char* my_strstr( const char* s1, const char* s2 ){<br>&#9;size_t n = strlen( s2 );<br>&#9;for( const unsigned char* p1 = (const unsigned char*)s1; *p1; p1++ ){<br>&#9;&#9;if( strncmp( (const char*)p1, s2, n ) == 0 ) return (char*)p1;<br>&#9;&#9;if( my_iskanji1( *p1 ) &amp;&amp; *(p1+1) != 0 ) p1++;<br>&#9;}<br>&#9;return NULL;<br>}<br><br>char* my_strchri( const char* s1, int c2 ){<br>&#9;int C2 = my_toupper( c2 );<br>&#9;for( const unsigned char* p1 = (const unsigned char*)s1; *p1; p1++ ){<br>&#9;&#9;if( my_toupper( *p1 ) == C2 ) return (char*)p1;<br>&#9;&#9;if( my_iskanji1( *p1 ) &amp;&amp; *(p1+1) != 0 ) p1++;<br>&#9;}<br>&#9;return NULL;<br>}<br><br>char* my_strchr( const char* s1, int c2 ){<br>&#9;for( const unsigned char* p1 = (const unsigned char*)s1; *p1; p1++ ){<br>&#9;&#9;if( *p1 == c2 ) return (char*)p1;<br>&#9;&#9;if( my_iskanji1( *p1 ) &amp;&amp; *(p1+1) != 0 ) p1++;<br>&#9;}<br>&#9;return NULL;<br>}<br></div></section>
    <ul><li><section><h1 id=3917>
    <span class="no">[3917]</span>
    <a class="title" href="#3917">Re10: キーワードを指定してタグジャンプ</a>
    <span class="author">げんた</span>
    <time datetime="2005-04-17T19:53:12">2005年04月17日 19:53</time></h1>
    <div class="body">ポインタp1そのものをunsigned char*とすると，キャストが必要な場所が三カ所出来てしまうので，unsigned char*で無いと符号拡張されて都合の悪いkanji1だけキャストするようにしてみました．<br><br>▼my_icmp.h<br>// 2005.04.07 MIK strstr系関数追加<br>#ifdef strstri<br>#  undef strstri<br>#endif<br>#define strstri(a,b)        my_strstri((a),(b))<br>#ifdef strchri<br>#  undef strchri<br>#endif<br>#define strchri(a,b)        my_strchri((a),(b))<br><br>(中略)<br>// 2005.04.07 MIK strstr系関数追加<br>SAKURA_CORE_API const char* __cdecl my_strstri( const char* s1, const char* s2 );<br>SAKURA_CORE_API const char* __cdecl my_strstr( const char* s1, const char* s2 );<br>SAKURA_CORE_API const char* __cdecl my_strchri( const char* s1, int c2 );<br>SAKURA_CORE_API const char* __cdecl my_strchr( const char* s1, int c2 );<br><br>inline SAKURA_CORE_API char* __cdecl my_strstri( char* s1, const char* s2 )<br>{<br>&#9;return const_cast&lt;char*&gt;(my_strstri((const char*)s1, s2));<br>}<br><br>inline SAKURA_CORE_API char* __cdecl my_strstr( char* s1, const char* s2 )<br>{<br>&#9;return const_cast&lt;char*&gt;(my_strstr((const char*)s1, s2));<br>}<br><br>inline SAKURA_CORE_API char* __cdecl my_strchri( char* s1, int c2 )<br>{<br>&#9;return const_cast&lt;char*&gt;(my_strchri((const char*)s1, c2));<br>}<br><br>inline SAKURA_CORE_API char* __cdecl my_strchr( char* s1, int c2 )<br>{<br>&#9;return const_cast&lt;char*&gt;(my_strchr((const char*)s1, c2));<br>}<br><br>サイズオーバーのため次へ続く<br></div></section>
    </li><li><section><h1 id=3918>
    <span class="no">[3918]</span>
    <a class="title" href="#3918">Re10: キーワードを指定してタグジャンプ</a>
    <span class="author">げんた</span>
    <time datetime="2005-04-17T19:54:01">2005年04月17日 19:54</time></h1>
    <div class="body">&gt;&gt;3917 の続きです．<br><br>▼my_icmp.c<br>/*!<br>&#9;strstr()の大文字小文字同一視版<br><br>&#9;@note<br>&#9;Windows APIにあるStrStrIはIE4が入っていないPCでは使用不可のため<br>&#9;独自に作成<br><br>&#9;@date 2005.04.07 MIK 新規作成<br>*/<br>const char* my_strstri( const char* s1, const char* s2 ){<br>&#9;size_t n = strlen( s2 );<br>&#9;for( const char* p1 = s1; *p1; p1++ ){<br>&#9;&#9;if( my_strnicmp( p1, s2, n ) == 0 ) return p1;<br>&#9;&#9;if( my_iskanji1( *(const unsigned char*)p1 ) &amp;&amp; *(p1+1) != 0 ) p1++;<br>&#9;}<br>&#9;return NULL;<br>}<br><br>/*!<br>&#9;strstr()の2byte code対応版<br><br>&#9;@date 2005.04.07 MIK 新規作成<br>*/<br>const char* my_strstr( const char* s1, const char* s2 ){<br>&#9;size_t n = strlen( s2 );<br>&#9;for( const char* p1 = s1; *p1; p1++ ){<br>&#9;&#9;if( strncmp( p1, s2, n ) == 0 ) return p1;<br>&#9;&#9;if( my_iskanji1( *(const unsigned char*)p1 ) &amp;&amp; *(p1+1) != 0 ) p1++;<br>&#9;}<br>&#9;return NULL;<br>}<br><br>/*!<br>&#9;@date 2005.04.07 MIK 新規作成<br>*/<br>const char* my_strchri( const char* s1, int c2 ){<br>&#9;int C2 = my_toupper( c2 );<br>&#9;for( const char* p1 = s1; *p1; p1++ ){<br>&#9;&#9;if( my_toupper( *p1 ) == C2 ) return p1;<br>&#9;&#9;if( my_iskanji1( *(const unsigned char*)p1 ) &amp;&amp; *(p1+1) != 0 ) p1++;<br>&#9;}<br>&#9;return NULL;<br>}<br><br>/*!<br>&#9;@date 2005.04.07 MIK 新規作成<br>*/<br>const char* my_strchr( const char* s1, int c2 ){<br>&#9;for( const char* p1 = s1; *p1; p1++ ){<br>&#9;&#9;if( *p1 == c2 ) return p1;<br>&#9;&#9;if( my_iskanji1( *(const unsigned char*)p1 ) &amp;&amp; *(p1+1) != 0 ) p1++;<br>&#9;}<br>&#9;return NULL;<br>}<br>/*[EOF]*/<br></div></section>
    </li></ul></li></ul></li></ul></li></ul></li><li><section><h1 id=3927>
    <span class="no">[3927]</span>
    <a class="title" href="#3927">Re6: キーワードを指定してタグジャンプ</a>
    <span class="author">みく</span>
    <time datetime="2005-04-21T19:12:47">2005年04月21日 19:12</time></h1>
    <div class="body"><br>バグ修正。<br>ダイレクトタグジャンプで選んだ箇所にジャンプしない。<br>パッチを当てた後の行番号で、<br>CTagJumpList.cpp:GetData()の267-269行目をifの前に移動<br><br>+&#9;hwndList = ::GetDlgItem( m_hWnd, IDC_LIST_TAGJUMP );<br>+&#9;m_nIndex = ListView_GetNextItem( hwndList, -1, LVIS_SELECTED );<br>+&#9;if( m_nIndex == -1 || m_nIndex &gt;= MAX_TAGJUMPLIST ) return FALSE;<br><br>&#9;if( 0 != m_lParam )<br>&#9;{<br>&#9;&#9;m_pShareData-&gt;m_bTagJumpICase = m_bTagJumpICase;<br>&#9;&#9;m_pShareData-&gt;m_bTagJumpAnyWhere = m_bTagJumpAnyWhere;<br><br>-&#9;&#9;hwndList = ::GetDlgItem( m_hWnd, IDC_LIST_TAGJUMP );<br>-&#9;&#9;m_nIndex = ListView_GetNextItem( hwndList, -1, LVIS_SELECTED );<br>-&#9;&#9;if( m_nIndex == -1 || m_nIndex &gt;= MAX_TAGJUMPLIST ) return FALSE;<br></div></section>
    </li></ul></li></ul></li></ul></li></ul></li><li><section><h1 id=3938>
    <span class="no">[3938]</span>
    <a class="title" href="#3938">Re2: キーワードを指定してタグジャンプ</a>
    <span class="author">みく</span>
    <time datetime="2005-06-01T21:09:31">2005年06月01日 21:09</time></h1>
    <div class="body"><br>＃げんたさんの言ってた意味がわかったような。。。<br><br>管理個数が100個<br>1個目のtagsファイルでヒットするレコードが120件<br>2個目のtagsファイルでヒットするレコードが130件<br>あったとして、<br>tagsファイルはソートされてるので<br><br>1個目で100個登録した時点でそのtagsファイルの検索を打ち切る。<br>2個目で100個登録した時点でそのtagsファイルの検索を打ち切る。<br><br>という動作でよいような気がします。<br><br>find_key()関数でnMatch++してるので、<br>nMatchがMAX値になったら、そのファイルの検索を打ち切るように<br>条件を追加すればファイルを最後まで全部なめなくてもすみます。<br></div></section>
    <ul><li><section><h1 id=3973>
    <span class="no">[3973]</span>
    <a class="title" href="#3973">Re3: キーワードを指定してタグジャンプ</a>
    <span class="author">げんた</span>
    <time datetime="2005-07-09T22:55:24">2005年07月09日 22:55</time></h1>
    <div class="body">&gt;1個目のtags<br>&gt;2個目のtags<br>そうか，tagsファイルが複数あったら全部見てくれるんですね．<br>tagsファイルが一つだけなら溢れ処理は不要かと思ってしまいました．<br><br>どうも最近同じものがちょっと違ったパスでヒットするなあと思っていてこの仕様に気付きました．<br></div></section>
    </li></ul></li></ul></li></ul></li></ul></body></html>