<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta http-equiv="Content-Style-Type" content="text/css">
  <script src='../bbs.js'></script>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-120820034-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-120820034-1');
  </script>

  <link href="../bbs.css">
  <link rel="shortcut icon" href="favicon.ico">
  <title>システムリソース不即時のエラー処理 | サクラエディタ過去ログ</title>
</head>
<body>
<ul class="side">
        <a href="./" class="toindex">◀ANSI版開発トップへ</a>
        <li><div class="list-title">
    <span class="no">4235</span>
    <a class="thread-title" href="4235.html#4235">システムリソース不即時のエラー処理</a></div>
    <ul><li><div class="list-title">
    <span class="no">4236</span>
    <a class="thread-title" href="4235.html#4236">Re:システムリソース不即時のエラー処理</a></div>
    <ul><li><div class="list-title">
    <span class="no">4237</span>
    <a class="thread-title" href="4235.html#4237">Re2:システムリソース不即時のエラー処理</a></div>
    </li></ul></li><li><div class="list-title">
    <span class="no">4239</span>
    <a class="thread-title" href="4235.html#4239">Re: システムリソース不即時のエラー処理</a></div>
    <ul><li><div class="list-title">
    <span class="no">4240</span>
    <a class="thread-title" href="4235.html#4240">Re2: システムリソース不即時のエラー処理</a></div>
    <ul><li><div class="list-title">
    <span class="no">4241</span>
    <a class="thread-title" href="4235.html#4241">Re3: システムリソース不即時のエラー処理</a></div>
    <ul><li><div class="list-title">
    <span class="no">4245</span>
    <a class="thread-title" href="4235.html#4245">Re4: システムリソース不即時のエラー処理</a></div>
    <ul><li><div class="list-title">
    <span class="no">4246</span>
    <a class="thread-title" href="4235.html#4246">Re5: システムリソース不即時のエラー処理</a></div>
    <ul><li><div class="list-title">
    <span class="no">4247</span>
    <a class="thread-title" href="4235.html#4247">Re6: システムリソース不即時のエラー処理</a></div>
    <ul><li><div class="list-title">
    <span class="no">4248</span>
    <a class="thread-title" href="4235.html#4248">Re7: システムリソース不即時のエラー処理</a></div>
    </li></ul></li></ul></li></ul></li><li><div class="list-title">
    <span class="no">4249</span>
    <a class="thread-title" href="4235.html#4249">リソース不足時 CMemory クラスのふるまいの件</a></div>
    <ul><li><div class="list-title">
    <span class="no">4273</span>
    <a class="thread-title" href="4235.html#4273">Re5: システムリソース不即時のエラー処理</a></div>
    <ul><li><div class="list-title">
    <span class="no">4276</span>
    <a class="thread-title" href="4235.html#4276">Re6: システムリソース不即時のエラー処理</a></div>
    <ul><li><div class="list-title">
    <span class="no">4278</span>
    <a class="thread-title" href="4235.html#4278">Re7: システムリソース不即時のエラー処理</a></div>
    </li></ul></li><li><div class="list-title">
    <span class="no">4277</span>
    <a class="thread-title" href="4235.html#4277">Re6: システムリソース不即時のエラー処理</a></div>
    </li><li><div class="list-title">
    <span class="no">4279</span>
    <a class="thread-title" href="4235.html#4279">Re6: システムリソース不即時のエラー処理</a></div>
    </li></ul></li><li><div class="list-title">
    <span class="no">4281</span>
    <a class="thread-title" href="4235.html#4281">Re:リソース不足時 CMemory クラスのふるまいの件</a></div>
    <ul><li><div class="list-title">
    <span class="no">4285</span>
    <a class="thread-title" href="4235.html#4285">Re2:リソース不足時 CMemory クラスのふるまいの件</a></div>
    <ul><li><div class="list-title">
    <span class="no">4291</span>
    <a class="thread-title" href="4235.html#4291">Re3:リソース不足時 CMemory クラスのふるまいの件</a></div>
    <ul><li><div class="list-title">
    <span class="no">4292</span>
    <a class="thread-title" href="4235.html#4292">Re4:リソース不足時 CMemory クラスのふるまいの件</a></div>
    </li></ul></li></ul></li></ul></li></ul></li><li><div class="list-title">
    <span class="no">4261</span>
    <a class="thread-title" href="4235.html#4261">システムリソース不足時の例外処理の件</a></div>
    <ul><li><div class="list-title">
    <span class="no">4283</span>
    <a class="thread-title" href="4235.html#4283">Re:システムリソース不足時の例外処理の件</a></div>
    <ul><li><div class="list-title">
    <span class="no">4287</span>
    <a class="thread-title" href="4235.html#4287">Re2:システムリソース不足時の例外処理の件</a></div>
    </li><li><div class="list-title">
    <span class="no">4288</span>
    <a class="thread-title" href="4235.html#4288">Re2:システムリソース不足時の例外処理の件</a></div>
    </li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li>
    </ul><ul class="main"><li><section><h1 id=4235>
    <span class="no">[4235]</span>
    <a class="thread-title" href="#4235">システムリソース不即時のエラー処理</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-01-30T01:13:24">2006年01月30日 01:13</time></h1>
    <div class="body">これまた唐突で恐縮です.<br><br>・1999.06.14 □  ----.--.-- システムリソース不足時のエラー処理が不十分<br><br>これについて, CMemory, CDocLine, CLayout 周りだけ見て回ったところ,<br><br>・malloc() realloc() のラッパークラス or 関数を作る.<br>・new, new[], delete, delete[] 演算子を malloc() free() で実装しなおす.<br>・これらを基にして,「メモリが足りません」状態を統一的に捕捉する.<br><br>とすると, かなり大掛かりで大胆ですが, 解決するのではないかと思いました(感想).<br>ウインドウ操作系のコードをまったく読めない私が見てもどうしようもありませんが.<br></div></section>
    <ul><li><section><h1 id=4236>
    <span class="no">[4236]</span>
    <a class="thread-title" href="#4236">Re:システムリソース不即時のエラー処理</a>
    <span class="author">(全略)</span>
    <time datetime="2006-01-30T23:35:54">2006年01月30日 23:35</time></h1>
    <div class="body">&gt; ・malloc() realloc() のラッパークラス or 関数を作る.<br>&gt; ・new, new[], delete, delete[] 演算子を malloc() free() で実装しなおす.<br>システムリソースとの関係がよく分かりませんがメモリーリークの対応策でしょうか?<br>メモリリークの対策にmallocとfreeを使うのは本末転倒だと思うのですが</div></section>
    <ul><li><section><h1 id=4237>
    <span class="no">[4237]</span>
    <a class="thread-title" href="#4237">Re2:システムリソース不即時のエラー処理</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-01-31T00:40:09">2006年01月31日 00:40</time></h1>
    <div class="body">&gt;システムリソースとの関係がよく分かりませんがメモリーリークの対応策でしょうか?<br>&gt;メモリリークの対策にmallocとfreeを使うのは本末転倒だと思うのですが<br><br>何かのオブジェクトを作成する際,<br>(今時は滅多に起きない, という意味で) 高がメモリ不足ごときに,<br>try-catch ブロックみたいなのをいちいち書くのも うっとうしいかと思いまして.<br>メモリ確保の手段を統一するという目的も兼ねて,<br>new delete 関係の演算子をオーバーライドして,<br>「メモリを確保できませんでした」なんてことを言わせなくする,<br>なんてことを考えてたのですが,<br>…メモリリークの問題に対しては本末転倒でした.<br><br>言葉足らずですみません.<br></div></section>
    </li></ul></li><li><section><h1 id=4239>
    <span class="no">[4239]</span>
    <a class="thread-title" href="#4239">Re: システムリソース不即時のエラー処理</a>
    <span class="author">げんた</span>
    <time datetime="2006-01-31T23:20:40">2006年01月31日 23:20</time></h1>
    <div class="body">&gt;・これらを基にして,「メモリが足りません」状態を統一的に捕捉する. <br>統一的にというのは<br>→ファイルを開く途中ならキャンセルして終了<br>→文字列操作・コマンド処理なら元に戻す<br>ということでしょうかね．<br><br>ただ全てを一カ所で捕捉できればいいのですが，場合によっては元の状態に戻さなくてはならなかったりとかあるように思います．<br>(Copyで半分貼り付けたところで溢れた場合に戻すかどうかとか)<br><br>そういえばこのエディタは無限Undoを謳っていますが，これはUndoバッファを永遠に解放しないと言うことなのでずっと使っていたらいつかメモリ不足になるような...違ったかな．<br></div></section>
    <ul><li><section><h1 id=4240>
    <span class="no">[4240]</span>
    <a class="thread-title" href="#4240">Re2: システムリソース不即時のエラー処理</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-02-01T08:33:06">2006年02月01日 08:33</time></h1>
    <div class="body">&gt; 統一的にというのは<br>&gt; →ファイルを開く途中ならキャンセルして終了<br>&gt; →文字列操作・コマンド処理なら元に戻す<br>&gt; ということでしょうかね．<br><br>呼び出し側に告知するだけでも, 効果的かと思いまして.<br><br>&gt; ただ全てを一カ所で捕捉できればいいのですが，<br>&gt; 場合によっては元の状態に戻さなくてはならなかったりとかあるように思います．<br>&gt; (Copyで半分貼り付けたところで溢れた場合に戻すかどうかとか)<br><br>自由領域アロケーター (CMemory クラスや malloc とか) から例外を受け取れるように,<br>仕様を変更するのが良いかと思ったのですが,<br>既存コードとの折り合いからすると,<br>なんだか難しそうなので…<br><br>復元しようの無い場所で「メモリが足りません」状態に<br>陥った場合, いっそのこと致命的エラー扱いということで,<br>メモリ不足で落ちそうな場所に出来れば限定して,<br>new, delete 演算子をオーバーロードさせておいて,<br>その例外処理ハンドラによって編集中のファイルを<br>復元時のためにディスクへ退避させて,<br>プロセスを仕方なく消す方向で処理するとか…<br>なら, 出来なくなさそうかなーと, 想像しています.<br></div></section>
    <ul><li><section><h1 id=4241>
    <span class="no">[4241]</span>
    <a class="thread-title" href="#4241">Re3: システムリソース不即時のエラー処理</a>
    <span class="author">(全略)</span>
    <time datetime="2006-02-01T21:07:37">2006年02月01日 21:07</time></h1>
    <div class="body">▼ ラスティブさん<br>&gt; 自由領域アロケーター (CMemory クラスや malloc とか) から例外を受け取れるように,<br>&gt; 仕様を変更するのが良いかと思ったのですが,<br>&gt; 既存コードとの折り合いからすると,<br>&gt; なんだか難しそうなので…<br>冒頭で言われていたのはmallocやHeapAllocとかのラッパー関数から<br>失敗した場合bad_alloc例外を投げたりする、と言うことだったのでしょうか(^-^;?<br><br>&gt; 復元しようの無い場所で「メモリが足りません」状態に<br>&gt; 陥った場合, いっそのこと致命的エラー扱いということで,<br>&gt; メモリ不足で落ちそうな場所に出来れば限定して,<br>&gt; new, delete 演算子をオーバーロードさせておいて,<br>&gt; その例外処理ハンドラによって編集中のファイルを<br>&gt; 復元時のためにディスクへ退避させて,<br>&gt; プロセスを仕方なく消す方向で処理するとか…<br>&gt; なら, 出来なくなさそうかなーと, 想像しています.<br>SetUnhandledExceptionFilterで例外ハンドラを設定しておいて、そこで無理矢理保存を行うとか、、、<br>自家用のビルドでやっていますが、それなりに機能しています<br><br># もっともnewすら失敗するようなテンパった状況では保存処理すら失敗するかもしれませんが^^;</div></section>
    <ul><li><section><h1 id=4245>
    <span class="no">[4245]</span>
    <a class="thread-title" href="#4245">Re4: システムリソース不即時のエラー処理</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-02-07T06:15:16">2006年02月07日 06:15</time></h1>
    <div class="body">新しく作った CMem クラスをブリーフケースに上げときました. (バグがないことを願いつつ... CMem.zip )<br>下手すると標準ライブラリの vector クラスとダブってしまうので,<br>Sakura 向けに, 機能は必要最低限.<br><br>これを基にして文字列操作部分を作れば, <br>少なくとも文字コード変換中に落ちることはなくなる<br>…かもと思ってますけど, 過去ログにもありましたが,<br>モジュールを CString, CCharTypes, とかに分けないとですね…；；<br><br>&gt; SetUnhandledExceptionFilterで例外ハンドラを設定しておいて、そこで無理矢理保存を行うとか、、、<br><br>実装できてません；；<br>かなり力量不足でした.<br><br>過去ログより：<br><br>Unicode 化について (dev:2969)<br>&gt; ・管理するデータ専用の型(例:MOJI)を新たに作成して、それで書き換える。<br>&gt; 　（ただし、実態はwchar_tである）<br><br>最後尾につける番兵を２バイトに増やしました (バイナリデータに対しては無意味ですが一応).<br>ここで言ってる「管理するデータ」ってのがいまいち解りませんが...<br>BYTE 単位で統一しました. 可変長マルチバイト文字を処理するのに困ると思いますし.<br><br>速度について (dev:1318)<br>&gt; … 削除・挿入時にいったんメモリを別に確保して<br>&gt; そちらにコピーし、最後にCMemoryにSetDataSzしていること。<br>&gt; この辺をCMemoryにやらせればメモリ転送が減るような気が...<br><br>memcpy memmove に毛が生えたようなもので対応しました.<br>挿入なんていう高尚なことはしないで,<br>ただただ上書きするだけです.<br>実際に計ったわけではないですが,<br>たぶん超遅いので使い物になるかどうか.<br></div></section>
    <ul><li><section><h1 id=4246>
    <span class="no">[4246]</span>
    <a class="thread-title" href="#4246">Re5: システムリソース不即時のエラー処理</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-02-07T21:35:16">2006年02月07日 21:35</time></h1>
    <div class="body">自己レス<br>&gt; 新しく作った CMem クラスをブリーフケースに上げときました. <br>&gt; (バグがないことを願いつつ... CMem.zip )<br>すみません.<br>都合により引数の順序を変更しました. → CMem1_1.zip<br>お間違いのありませんよう…<br></div></section>
    <ul><li><section><h1 id=4247>
    <span class="no">[4247]</span>
    <a class="thread-title" href="#4247">Re6: システムリソース不即時のエラー処理</a>
    <span class="author">げんた</span>
    <time datetime="2006-02-08T01:03:40">2006年02月08日 01:03</time></h1>
    <div class="body">CMem拝見しました．<br>ところで，これとここまでの異常時に保存くらいは出来るかどうかという話とどうつながるのかがわからなかったんですが，説明して頂けませんか？どういった点が大きなポイントなのかが見ただけではよくわからなかったので．<br></div></section>
    <ul><li><section><h1 id=4248>
    <span class="no">[4248]</span>
    <a class="thread-title" href="#4248">Re7: システムリソース不即時のエラー処理</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-02-08T13:58:46">2006年02月08日 13:58</time></h1>
    <div class="body">&gt; これとここまでの異常時に保存くらいは出来るかどうかという話とどうつながるのか<br><br>&gt;&gt; SetUnhandledExceptionFilterで例外ハンドラを設定しておいて、そこで無理矢理保存を行うとか、、、<br>&gt;<br>&gt;実装できてません；；<br>&gt;かなり力量不足でした.<br><br>と書いたように, 例外機構を上手くデザインするまでにはこぎつけなかったというオチ…. それとは別件で, 過去 CMemory に要求された事項をできる範囲で施しました.<br><br>確かに支離滅裂…；； すみません.<br><br>&gt; どういった点が大きなポイントか<br><br>CMemory の AllocBuffer と比較するなら「失敗」を呼び出し側に報告することができる点と, オブジェクトサイズを表すのに typedef unsigned int size_t 型を使っている点.  CMemory は大変保守性が悪そうなので... その将来を考えて CMemory と別個に書きました.  CMemory は Java で言うインターフェース見たいに機能してくれると願って.<br><br>板汚し失礼しました.<br></div></section>
    </li></ul></li></ul></li></ul></li><li><section><h1 id=4249>
    <span class="no">[4249]</span>
    <a class="thread-title" href="#4249">リソース不足時 CMemory クラスのふるまいの件</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-02-09T02:05:59">2006年02月09日 02:05</time></h1>
    <div class="body">&gt;&gt;&gt; SetUnhandledExceptionFilterで例外ハンドラを設定しておいて、そこで無理矢理保存を行うとか、、、<br><br>CMemory が行うメモリ管理の詳細を CMem クラスで隠す.  もし CMem 傘下の関数が Error を投げてきたら CMemory は...<br><br>1. 文字コード変換処理, 置換処理なら「失敗しました」と戻り値で報告,<br>2. AllocBuffer, Set* 系, Append* 系なら 内部エラーとして (例えば) CError_Fatal を再び投げる,<br>までは考えられます.<br><br>&gt;・1999.06.02 □  ----.--.-- 巨大なテキスト全体を「E-Mailコード変換」したら落ちたけん<br><br>16MBほど (全部 ASCII文字) のファイルを開いて変換して, 再現しませんが(ASCII だから？ でないとすれば直ってるのかもしれない), 1 の手でこれに対処できたらひとまず嬉.<br>それに関連して, MemSJIStoJIS って, 文字を一つ一つコピーしてから処理して, また同じ位置に戻す仕組みになってるんですけど... 実のところどうなんでしょう.<br></div></section>
    <ul><li><section><h1 id=4273>
    <span class="no">[4273]</span>
    <a class="thread-title" href="#4273">Re5: システムリソース不即時のエラー処理</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-02-20T16:40:53">2006年02月20日 16:40</time></h1>
    <div class="body">&gt; CMemory が行うメモリ管理の詳細を CMem クラスで隠す.<br>→ Developer / Source / CMem_and_CMemory.zip<br><br>カット＆ペーストするときに改行を含めると,<br>なぜかごみまでペーストされるようになってしまいました；；<br>かなり使い物にならないのですが,<br>意外なところに副作用が出て見当が付かないので,<br>どなたか詳しい人, 添削してくだされば幸いです m(_ _)m<br></div></section>
    <ul><li><section><h1 id=4276>
    <span class="no">[4276]</span>
    <a class="thread-title" href="#4276">Re6: システムリソース不即時のエラー処理</a>
    <span class="author">げんた</span>
    <time datetime="2006-02-21T02:24:24">2006年02月21日 02:24</time></h1>
    <div class="body">&gt;どなたか詳しい人, 添削してくだされば幸いです m(_ _)m<br>添削ではありませんが，Pasteデータを改行で分離しているのは<br>CDocLineMgr::InsertData_CDocLineMgr()<br>あたりなので，この辺を調べてみては？<br></div></section>
    <ul><li><section><h1 id=4278>
    <span class="no">[4278]</span>
    <a class="thread-title" href="#4278">Re7: システムリソース不即時のエラー処理</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-02-21T12:43:25">2006年02月21日 12:43</time></h1>
    <div class="body">▼ げんたさん<br>&gt; CDocLineMgr::InsertData_CDocLineMgr()<br>&gt; あたりなので，この辺を調べてみては？<br><br>アドバイスありがとうございます.<br>その辺りも視野に入れながらチェック中です.<br>いちばん疑わしいのは当然ながら<br>CMem クラスによる実装部分なのですが；；<br></div></section>
    </li></ul></li><li><section><h1 id=4277>
    <span class="no">[4277]</span>
    <a class="thread-title" href="#4277">Re6: システムリソース不即時のエラー処理</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-02-21T07:21:21">2006年02月21日 07:21</time></h1>
    <div class="body">&gt; CMemory が行うメモリ管理の詳細を CMem クラスで隠す.<br>→ Developer / Source / CMem_and_CMemory_0.1v.zip<br><br>・CMem の ExchangeFor() 関数のつくり間違い系バグを修復.<br></div></section>
    </li><li><section><h1 id=4279>
    <span class="no">[4279]</span>
    <a class="thread-title" href="#4279">Re6: システムリソース不即時のエラー処理</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-02-21T16:29:10">2006年02月21日 16:29</time></h1>
    <div class="body">&gt; CMemory が行うメモリ管理の詳細を CMem クラスで隠す.<br> → Developer / Source / CMem_and_CMemory_1.0v.zip<br><br>・AllocBuffer() の意味を取り違えて CMem 側で Resize() と解釈していたのを, Expand() に変更することで修復完了.<br>追記：<br>スクロール時に起こる CPU ファンの音は少し静かになりましたが...<br>以前からの伝統的な AllocBuffer ではなくなった可能性がありますのでご注意ください.<br>追記その２：<br>&gt;スクロール時に起こる CPU ファンの音は少し静かになりましたが...<br>大嘘でした. ウインドウ領域が小さかっただけというオチ.<br></div></section>
    </li></ul></li><li><section><h1 id=4281>
    <span class="no">[4281]</span>
    <a class="thread-title" href="#4281">Re:リソース不足時 CMemory クラスのふるまいの件</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-02-22T08:43:07">2006年02月22日 08:43</time></h1>
    <div class="body">&gt; 1. 文字コード変換処理, 置換処理なら「失敗しました」と戻り値で報告,<br><br>この件について取り掛かりたいのですけれど, どうも水面下で CEncoder クラスというのがあるようなのでスキップします.<br>他のクラスと帳尻が合わなくなるという残念な事態を避けるべく.<br># 過去ログにそのクラスのソースコードがアップされてありましたけど, 覗けないようです；；<br></div></section>
    <ul><li><section><h1 id=4285>
    <span class="no">[4285]</span>
    <a class="thread-title" href="#4285">Re2:リソース不足時 CMemory クラスのふるまいの件</a>
    <span class="author">dskoba</span>
    <time datetime="2006-02-23T01:09:07">2006年02月23日 01:09</time></h1>
    <div class="body">&gt; この件について取り掛かりたいのですけれど, どうも水面下で CEncoder クラスというのがあるようなのでスキップします.<br>&gt; # 過去ログにそのクラスのソースコードがアップされてありましたけど, 覗けないようです；；<br><br>http://www2.wbs.ne.jp/~dskoba/products/<br><br>基本的なエンコードのみ出来ています。メールヘッダのデコードのあたりで止まってます。<br>大文字&lt;--&gt;小文字，ひらがな&lt;--&gt;カタカナ，なども加えようかと思ってますが手づけずです。<br></div></section>
    <ul><li><section><h1 id=4291>
    <span class="no">[4291]</span>
    <a class="thread-title" href="#4291">Re3:リソース不足時 CMemory クラスのふるまいの件</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-03-07T07:03:00">2006年03月07日 07:03</time></h1>
    <div class="body">▼ dskobaさん<br>&gt; http://www2.wbs.ne.jp/~dskoba/products/<br>&gt; <br>&gt; 基本的なエンコードのみ出来ています。メールヘッダのデコードのあたりで止まってます。<br>&gt; 大文字&lt;--&gt;小文字，ひらがな&lt;--&gt;カタカナ，なども加えようかと思ってますが手づけずです。<br><br>→ ブリーフケース/Developer/Source/sdiff_2006-02-19_CMemFixed_3v.zip<br><br>いろいろまだ途中ですが一旦アップ.<br><br>・CEncodingConverter.cpp で文字コード変換ルーチンを差し替えた.<br>  (試行錯誤の末, CEncoder は本家のものとは別物となってしまいました. なんというか, 申し訳ありません.)<br>・スペース→タブ変換の仕様を少し変えた.(emacs 風にした.)<br>  (不評でしたら戻します;;)<br>・文字コード判別に, wchar 版 CMemroy にあったアイデア(NUL バイトの数を数えるというやつ)を取り入れた.<br>・メモリ不足になるとbad_alloc 例外が確実に飛んでくるように(たぶん)なった.<br>・new 演算子の修繕コードを CMem クラスへ組み入れて, CSakuraObjectBase.h は消滅し, CError.h となった.<br>・charcode.h が大きく変わった.<br><br>本格的な例外処理は, 呼び出し側で実装することと相成りました….<br></div></section>
    <ul><li><section><h1 id=4292>
    <span class="no">[4292]</span>
    <a class="thread-title" href="#4292">Re4:リソース不足時 CMemory クラスのふるまいの件</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-03-07T22:18:12">2006年03月07日 22:18</time></h1>
    <div class="body">&gt; → ブリーフケース/Developer/Source/sdiff_2006-02-19_CMemFixed_3v.zip<br>無限ループ系バグが見つかったので, アップしなおしました；；<br>→ ブリーフケース/Developer/Source/sdiff_2006-02-19_CMemFixed_3.1v.zip<br>原因は解らずじまいですけれど,<br>メッセージヘッダのデコード部分を強化すると収まったような, そうでないような.<br>無事を祈ります….<br></div></section>
    </li></ul></li></ul></li></ul></li></ul></li><li><section><h1 id=4261>
    <span class="no">[4261]</span>
    <a class="thread-title" href="#4261">システムリソース不足時の例外処理の件</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-02-16T19:45:30">2006年02月16日 19:45</time></h1>
    <div class="body">例外処理について検討中.  考えをまとめるついでにカキコ.<br><br>try-catch ブロックを散らばらせずにメモリを確保しようと思うと,<br><br>[3320] newの失敗の検出方法 by もか氏<br>&gt;調べた限りでは、<br>&gt;NULLに統一したくてもBCC551ではnothrowが効かないことがある。<br>&gt;VC6では operator delete( size_t, nothrow_t&amp; ); が未宣言。<br>&gt;VC7xではnewヘッダをインクルードするかしないかで動作が変わる。<br>&gt;set_new_handler()を使う場合もstaticなオブジェクトが、<br>&gt;それより先にnewを実行するかもしれない。<br><br>結局この問題にたどり着く.<br>大域で new 演算子をオーバーロードするわけにも行かず,<br># 一部の標準ライブラリで不都合が起こると言う話を小耳に挟んだ.<br>各クラスごとにわざわざ CMemory を使うのもかったるい,<br>というか不適切な場合もあるかもしれない.<br>では, こうしてみればどうか.<br><br>・標準 &lt;vector&gt; ライブラリで出来るところはそれでやる.<br>・文字列操作とかバッファリング操作とか, パフォーマンスが必要な場合は,<br>  string とか 自前の CMemory クラスとか, それなりのものを使う.<br><br>で, 標準ライブラリでは new の失敗時に何かの例外を発行してくれることを祈りながら,<br>その例外を上のほうのクラスで catch( ... ) ブロックで拾う... ( CProcess とか？ )<br><br>&gt;SetUnhandledExceptionFilterで例外ハンドラを設定しておいて、<br>&gt;そこで無理矢理保存を行う<br><br>ああ, そういえば既出でしたか... やっと意味がわかりました；；<br></div></section>
    <ul><li><section><h1 id=4283>
    <span class="no">[4283]</span>
    <a class="thread-title" href="#4283">Re:システムリソース不足時の例外処理の件</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-02-22T19:56:58">2006年02月22日 19:56</time></h1>
    <div class="body">メモリ不足ネタ, 続きます.<br><br>&gt; [3320] newの失敗の検出方法 by もか氏<br>&gt; &gt;調べた限りでは、<br>&gt; &gt;NULLに統一したくてもBCC551ではnothrowが効かないことがある。<br>&gt; &gt;VC6では operator delete( size_t, nothrow_t&amp; ); が未宣言。<br>&gt; &gt;VC7xではnewヘッダをインクルードするかしないかで動作が変わる。<br>&gt; &gt;set_new_handler()を使う場合もstaticなオブジェクトが、<br>&gt; &gt;それより先にnewを実行するかもしれない。<br>&gt; <br>&gt; 結局この問題にたどり着く.<br><br>つまり, デフォルトの new 演算子を信用すべからずってコトだと気づく.<br><br>&gt; ・標準 &lt;vector&gt; ライブラリで出来るところはそれでやる.<br>&gt; ・文字列操作とかバッファリング操作とか, パフォーマンスが必要な場合は, string とか 自前の CMemory クラスとか, それなりのものを使う.<br>&gt; <br>&gt; で, 標準ライブラリでは new の失敗時に何かの例外を発行してくれることを祈りながら,<br>&gt; その例外を上のほうのクラスで catch( ... ) ブロックで拾う... ( CProcess とか？ )<br><br>しかし vector&lt;T*&gt; 型を T** 型として扱う部分にも対応できないといけない. そのためには CMem をあっさり取りやめて, CMemory の内装を vector&lt;char&gt; あたりで統一するか, CMem をテンプレート化して, template&lt;&gt; CMem&lt;void*&gt; 型を提供するかのどちらかが必要か…<br>標準の型に縛られない自由さという点で後者が勝るけれど, 下手に作った道具よりも標準ライブラリの処理能力のほうが上という面では, 前者が勝る…<br><br>&gt; &gt;SetUnhandledExceptionFilterで例外ハンドラを設定しておいて、<br>&gt; &gt;そこで無理矢理保存を行う<br>&gt; <br>&gt; ああ, そういえば既出でしたか... やっと意味がわかりました；；<br><br>例外を投げない可能性のある new を使った時点でアウトだから…<br>CSakuraObjectBase(仮名) みたいなクラスに new, delete 一式をユーザー定義しておいて, そのクラスをすべてのクラスの基底とすれば処理系依存で悩むことはなくなりそうです.<br># 基底クラスの名付けで悩んでしまいます；；<br></div></section>
    <ul><li><section><h1 id=4287>
    <span class="no">[4287]</span>
    <a class="thread-title" href="#4287">Re2:システムリソース不足時の例外処理の件</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-02-23T15:22:53">2006年02月23日 15:22</time></h1>
    <div class="body">&gt; CSakuraObjectBase(仮名) みたいなクラスに new, delete 一式をユーザー定義しておいて, そのクラスをすべてのクラスの基底とすれば処理系依存で悩むことはなくなりそうです.<br>差分ファイルをアップしました.<br><br>Developer/Source/ sdiff_2006-02-19_CMemFixed_0v.zip<br>・CSakuraObject, CSakuraException の追加.<br>・CMemory の変更.<br>追記：<br>CEncoder の方はまだ組み込めてません. ごめんなさい.</div></section>
    </li><li><section><h1 id=4288>
    <span class="no">[4288]</span>
    <a class="thread-title" href="#4288">Re2:システムリソース不足時の例外処理の件</a>
    <span class="author">ラスティブ</span>
    <time datetime="2006-02-24T18:09:22">2006年02月24日 18:09</time></h1>
    <div class="body">&gt; [3320] newの失敗の検出方法 by もか氏<br>&gt; &gt;調べた限りでは、<br>&gt; &gt;NULLに統一したくてもBCC551ではnothrowが効かないことがある。<br>&gt; &gt;VC6では operator delete( size_t, nothrow_t&amp; ); が未宣言。<br>&gt; &gt;VC7xではnewヘッダをインクルードするかしないかで動作が変わる。<br>&gt; &gt;set_new_handler()を使う場合もstaticなオブジェクトが、<br>&gt; &gt;それより先にnewを実行するかもしれない。<br>&gt; &gt;<br>&gt; &gt; 結局この問題にたどり着く.<br>&gt; <br>&gt; つまり, デフォルトの new 演算子を信用すべからずってコトだと気づく.<br><br>しかしこれは, 標準ライブラリを一切使わないと言ってるのと同じ ってコトに気づく.<br><br>Developer/Source/ sdiff_2006-02-19_CMemFixed_1v.zip<br>・Microsoft のマニュアルに従って, Visual C++ の new 演算子を標準通りに正常に働かせるためのコードを追加.<br><br>CSakuraObject クラスの役割がこの修正ですっかり薄れてしまったのですけど, 他に何か用途とかあればと思い, そのままにしてます.<br>例外動作テストのために, Borland C++ 5.5.1 と Visual C++ 6.0 で実際に試したものを付けておきました.<br><br>&gt;NULLに統一したくてもBCC551ではnothrowが効かないことがある。<br><br>これに関しては,<br>#include &lt;new&gt;<br>#Include &lt;new.h&gt;<br>としておくと, こちらの環境では動いたので…<br>放置してますごめんなさい.<br></div></section>
    </li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></body></html>